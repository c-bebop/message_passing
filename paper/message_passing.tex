\documentclass[xcolor=dvipsnames]{article}

% Bibtex
\usepackage{cite, authordate1-4}
\usepackage{url}

% Open Sans Package!
\usepackage[default,scale=0.95]{opensans}
\usepackage[T1]{fontenc}

\usepackage[dvipsnames]{xcolor}
\definecolor{blue}{cmyk}{0.81,0.26,0,0.48}
\definecolor{red}{cmyk}{0,0.76,0.76,0.48}

% GLOSSAR BEGIN
\usepackage[acronym]{glossaries}

% Listing for Code
\usepackage{listings}

\definecolor{lbcolor}{rgb}{1,1,1}
\definecolor{mygray}{rgb}{0.3,0.3,0.3}
\lstset{ %
	language=Erlang,                % choose the language of the code
	basicstyle=\ttfamily\footnotesize\color{black},       % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\color{black}\footnotesize,      % the size of the fonts that are used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
	numbersep=3pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{lbcolor},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	%frame=single,           % adds a frame around the code
	tabsize=2,          % sets default tabsize to 2 spaces
	captionpos=b,           % sets the caption-position to bottom
	breaklines=true,        % sets automatic line breaking
	breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
	escapeinside={\%*}{*)},         % if you want to add a comment within your code
	keywordstyle=\color{red},
	commentstyle=\color{mygray},
	stringstyle=\color{black}
}

% Generate the glossary
\makenoidxglossaries

%Term definitions
\newacronym{os}{OS}{Operating System}
\newacronym{mpi}{MPI}{Message-Passing Interface}
\newacronym{rpc}{RPC}{Remote Procedure Calls}
\newacronym{tcp}{TCP/IP}{Transmission Control Protocol / Internet Protocol}
\newacronym{xml}{XML}{Extensible Markup Language}
\newacronym{json}{JSON}{JavaScript Object Notation}
\newacronym{ipc}{IPC}{Inter-Process Communication}
\newacronym{rtp}{RTP}{Real-Time Transport Protocol}
\newacronym{udp}{UDP}{User Datagram Protocol}
\newacronym{osi}{OSI}{Open Systems Interconnection Reference Model}
\newacronym{iso}{ISO}{International Organization for Standardization}
\newacronym{fifo}{FIFO}{First In - First Out}
\newacronym{pid}{pid}{Process Identifier}
\newacronym{mpif}{MPIF}{Message-Passing Interface Forum}

% GLOSSAR END

% For HTML conversion
%\usepackage{tex4ht}

\title{\scshape{\textbf{\textcolor{blue}{Introductory Guide to Message Passing}}\\In Distributed Computer Systems}}

\author{Florian Willich \\ Hochschule f\"ur Technik und Wirtschaft Berlin \\ University of Applied Sciences Berlin \\ Course: Distributed Systems \\ Lecturer: Prof. Dr. Christin Schmidt}
        
\date{\today}

\begin{document}

\maketitle

\begin{abstract}

Message passing in distributed systems is a model to exchange messages within a process pair by making use of several standards and implementation details. Those have been developed to offer the right message passing models for the different areas of applications. The programming language Erlang natively supports an asynchronous message passing model which makes the implementation of concurrent applications transparent to the software developer.

\end{abstract}

\tableofcontents

\newpage

\section{\scshape{\textcolor{blue}{Message Oriented Communication}}} \label{introduction}

\subsection{\scshape{Introduction}}

Communication in distributed systems defines a distributed system itself: N systems execute one or more tasks by computing and communicating with each other. Every time systems shall communicate with each other to provide services, a proficient communication model has to be implemented. There are several models of communication in distributed systems such as \gls{rpc} or object method invocation \cite[chap. 4.3 / p. 203]{tanenbaum}. With this paper I'll introduce you to the message passing model in distributed systems.\\

\noindent As human beings we already have a deep understanding of different models of message passing. When you read this words, I am passing a message to you, which seems to be a trivial thing to people who can read. In more philosophical terms, now that you read those words, a message is passed from one entity (me, the writer) to another entity (you, the reader) which is obviously non trivial considering all the assumptions we would've to make to actually perform this message passing model of human beings.\\

\noindent Message passing in distributed systems e.g. computer science is based on messages, composed of bit strings, exchanged within a process pair - which would be the equivalent to the entity pair. It is important to understand that message passing is a model designed for \gls{ipc}. Where those processes are located, on one or on different systems, is subsequent to the provided functionality.\\

\subsection{\scshape{Basic Requirements in Theory}}

\noindent The following items are the basic requirements (in theory) for a system to provide the functionality of message passing:

\begin{itemize}

\item \textbf{Connectivity}: A connection to communicate has to be established between the process pair
\item \textbf{Ability}: Each process has to be able to receive or send messages
\item \textbf{Integrity}: Send messages have to be delivered as is
\item \textbf{Intelligibility}: The receiving process has to be able to interpret the message as intended
\item \textbf{Executability}: The delivered message has to lead to an execution of the desired instructions

\end{itemize}

\subsection{\scshape{Requirements Provider in Practice}}

\noindent To provide the above mentioned requirements there have been developed several message passing models resulting in well defined standards and concrete implementations in the last decades. To make it easier to understand the relations between the theoretical requirements and a concrete implementation, I will take the \gls{tcp} which uses several socket primitives as example \cite[chap 4.3.1 on p. 141 - 142]{tanenbaum}:

\begin{itemize}

\item \textbf{Connectivity}: A communication end point has to be provided so the application can write data to and read data from: \gls{tcp} provides the \textit{Socket} primitive to create that end point and also the \textit{Bind} primitive to bind a local address to that socket. The \textit{Connect} primitive then provides the functionality to establish a connection.

\item \textbf{Ability}: \gls{tcp} provides the two primitives \textit{Send} and \textit{Receive} to simply send and receive data ?over? the connection. (A little but important detail: The \gls{os} has to reserve local memory to provide a buffer for the in- and outgoing messages)

\item \textbf{Integrity}: \gls{tcp} provides several mechanisms to ensure that there has been no data loss when sending or receiving messages. On the other hand this makes the protocol more slow than other protocols such as the \gls{rtp} or the \gls{udp}.

\end{itemize}

\noindent The requirements of \textbf{Intelligibility} and \textbf{Executability} do not depend on \gls{tcp} and thus other standards have to take place to provide those requirements such as \gls{xml} or \gls{json} to structure the messages in a standardized manner and last but not least the message parsing implementation to call the desired instructions.\\

\noindent There are other primitives than the above mentioned to provide the functionality of \gls{tcp}. If you're interested in reading more, I recommend you the referenced book \cite[ch. 4.3.1 on p. 141]{tanenbaum}.\\

\noindent It is also important to understand, that this was just a round-up of  how you could basically make use of the socket primitives to implement message passing in your application. There is plenty to discuss about how message passing is realized such as the \gls{osi} which was developed by the \gls{iso} to model the different layers of network oriented communication \cite[ch. 4.1.1 on p. 116]{tanenbaum}.

\subsection{\scshape{Asynchronous vs. Synchronous Message Passing}}

\noindent Now that we discussed a protocol to handle the socket primitives one major difference in message passing models is the whether we use asynchronous or synchronous message passing. Passing a message synchronously means that the called message send routine returns after the request has been successfully transmitted (or an error occurred). Receiving a message synchronously means that the called message receiving routine reads a specific amount of bytes from the socket and returns that message.\\

\noindent To pass or receive our message asynchronously another application layer or middleware has to take place. The call of a send routine can either return when the middleware \cite[ch. 4.1 on p. 125]{tanenbaum}:

\begin{enumerate}
\item took over the transmission of the request.
\item successfully send the request to the receiver.
\item successfully send the request to the receiver, assuring this by a corresponding message.
\end{enumerate}

\noindent The middleware can also perform some preparatory work e.g. separating stand alone request strings and parsing them into data structure and returning this more easy to parse data when calling the receive routine of the message passing middleware.\\

\noindent One key model to provide such middleware functionalities are message queues. A message queue is a queue to store messages by the \gls{fifo} principle. This enables the application to asynchronously send and receive messages by offering an incoming message queue and and outgoing message queue. This makes all the send and receive mechanisms fully transparent to the application \cite[ch. 4.3.2 on p. 145 - 147]{tanenbaum}

\section{\scshape{\textcolor{blue}{Message-Passing Interface Standard}}} \label{message_passing_interface}

The \gls{mpi} is a message-passing library interface specification, made for high performance and scale able distributed systems where high-efficiency is needed.  The \gls{mpi} standard was designed by the \gls{mpif} which is an open group with representatives from many organizations. The current version of the \gls{mpi} standard is MPI-3.0 \cite[ch. Abstract/ii \& Acknowledgements/xx \& 1.1 on p. 1]{mpi}.\\

\noindent The \gls{mpif} aims to offer a standard which establishes a practical, portable, efficient and flexible way of implementing message-passing in various high-level programming languages (e.g. C, C++, Fortran) \cite[ch. History/iii]{mpi}. Furthermore, the \gls{mpi} simplifies the communication primitives and brings them to an abstraction level to perfectly fit the programmers needs of writing efficient and clean code for such distributed systems \cite{tanenbaum}.\\

\noindent TCP does not fit those requirements. While the socket primitives \textit{read} and \textit{write} are sufficient for several general-purpose protocols, (managing the communication across networks) they are insufficient for high-speed interconnection networks such as super computers or server clusters. The \gls{mpi} standard offers a set of functions and datatypes with which the software developer is able to explicitly execute synchronous and asynchronous message passing routines \cite[ch. 4.3 on p. 143]{tanenbaum}.\\

\section{\scshape{\textcolor{blue}{Message Passing in Erlang}}} \label{erlang}

\subsection{Introduction}

Erlang is a functional, declarative programming language that was written for the need of real-time, non-stop, concurrent, very large and distributed system applications \cite[chap. 1 / p. 1]{Armstrong96erlang}. While the language was originally designed by Joe Armstrong, Robert Virding and Mike Williams for Ericsson (a Swedish telecommunications provider) in 1986, it finally became open source in 1998, thanks to the open source initiatives lead by Linux \cite[chap. 8 on p. 39]{erl_history}.\\

\noindent Since there is a lot confusion with the naming of Erlang: Joe Armstrong, who started to design Erlang by adding functionality to Prolog, named it after the Danish mathematician Agner Krarup Erlang (creator of the Erlang loss formula) following the tradition of naming programming languages after dead mathematicians \cite[chap. 4.1 on p. 13]{erl_history}.\\

\noindent Erlang uses a native, asynchronous message passing model to communicate between light weight processes, also called actors \cite[chap. 1 on p. 1]{Armstrong96erlang}. Erlang does not make heavy use of your \gls{os} to provide the described concurrency model which implicitly means that Erlang decouples the underlying \gls{os} and thus providing a cross-platform and transparent message passing model \cite[chap. 1  \& 3 on p. 1 - 3]{Armstrong96erlang}.

\subsection{Concurrency in Erlang}

\noindent Erlang provides semantics and built-in functions to parallelize your applications by message passing \cite[ch. 4.3 on p. 95 - 104]{erl_doc}:

\begin{itemize}

\item \textcolor{red}{spawn}(\textit{Module}, \textit{Exported Function}, \textit{List of Arguments})\\
Function which creates a new actor, by running the \textit{Exported Function} with the \textit{List of Arguments} located in the \textit{Module} (a set of functions located in one file) and returns the \gls{pid}, which uniquely identifies an actor, of it.\\

\item The \textcolor{red}{receive} construct that allows the function that is executed by an actor to receive messages by using a message queue.

\item The \textcolor{red}{!} operator which sends the right handed term to the left handed \gls{pid}. The right handed term is the message we send.

\item \textcolor{red}{self}() \\
Function that returns the \gls{pid} of the actor who executes the function.

\end{itemize}

\noindent Although the above described semantics and functions require a little knowledge on the Erlang programming language it was important for me to show you that Erlang is not only offering you an easy to understand interface for concurrency, it rather is a concurrent functional programming language. I recommend you to have a look into the referenced official Erlang documentation or to \textit{learn you some Erlang} on \url{www.learnyousomeerlang.com}.

\subsection{Implementation of a Simple Diffie-Hellman Key Exchange in Erlang}

The following implementation of a Diffie-Hellman key exchange algorithm in Erlang is simple and short. I'm explicitly committing that its not complete nor error free. You can find the code on Github:

\begin{center}
\url{https://github.com/c-bebop/message_passing}
\end{center}
and is licensed under the MIT License. You're welcome to contribute!

\lstinputlisting{../erlang_diffie_hellman/src/diffie_hellman.erl}

\subsection{Running the Simple Diffie-Hellman Key Exchange in Erlang}

\section{\scshape{\textcolor{blue}{Definition of Message Passing in Distributed Systems}}}

\begin{quote}
\textit{Message passing in distributed systems is a model to exchange messages within a process pair by making use of several standards and implementation details. The specifically used message passing model can diverge extremely in its provided functionality and defines how to provide the connection and send or receive messages whereas the physical conditions and the implementation of executing the desired instructions is undefined.}
\end{quote}

\newpage

\begin{appendix}

\section{my\_math Erlang Module}\label{my_math}

\lstinputlisting{../erlang_diffie_hellman/src/my_math.erl}

\section{Acronyms}

\printnoidxglossaries

\end{appendix}

\newpage

\bibliographystyle{authordate1}
\bibliography{lib}

\vfill
\begin{center}
This document was written with \LaTeX 
\\Typeface: Open Sans by Steve Matteson.
\end{center}

% To compile bibtex and latex manual:
% bibtex belegarbeit.aux
% latex belegarbeit.tex

\end{document}